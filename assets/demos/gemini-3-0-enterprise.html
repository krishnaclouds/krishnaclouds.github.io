<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini 3.0 Pro Beta (Enterprise) Thinking Model Generated Ocean Wave Simulation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        #ui-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 12px;
            color: #fff;
            width: 250px;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: opacity 0.3s;
        }

        #ui-panel:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        h1 {
            font-size: 1.2rem;
            margin: 0 0 15px 0;
            font-weight: 300;
            letter-spacing: 1px;
            text-transform: uppercase;
            text-align: center;
            border-bottom: 1px solid rgba(255,255,255,0.2);
            padding-bottom: 10px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            margin-bottom: 5px;
            font-weight: 300;
        }

        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 14px;
            width: 14px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            margin-top: -5px;
            box-shadow: 0 0 5px rgba(0,0,0,0.2);
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: rgba(255,255,255,0.3);
            border-radius: 2px;
        }
        
        input[type=range]:focus {
            outline: none;
        }

        .value-display {
            font-size: 0.8rem;
            opacity: 0.8;
        }
    </style>
</head>
<body>

    <div id="ui-panel">
        <h1>Gemini 3.0 (Enterprise)</h1>
        
        <div class="control-group">
            <label>Wind Speed <span id="val-speed" class="value-display">1.0</span></label>
            <input type="range" id="speed" min="0" max="3" step="0.1" value="1.0">
        </div>

        <div class="control-group">
            <label>Wave Height <span id="val-height" class="value-display">1.0</span></label>
            <input type="range" id="height" min="0" max="3.0" step="0.1" value="1.0">
        </div>

        <div class="control-group">
            <label>Lighting <span id="val-light" class="value-display">1.0</span></label>
            <input type="range" id="light" min="0.1" max="2.0" step="0.1" value="1.0">
        </div>
    </div>

    <div id="canvas-container"></div>

    <!-- Load Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- 1. Scene Setup ---
        const scene = new THREE.Scene();
        // Add a subtle fog for depth and realism
        scene.fog = new THREE.FogExp2(0x001e0f, 0.0025); 
        scene.background = new THREE.Color(0x001e0f);

        const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 1, 2000);
        camera.position.set(0, 30, 100);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // --- 2. Lighting ---
        const ambientLight = new THREE.AmbientLight(0x404040); // Soft white light
        scene.add(ambientLight);

        const moonLight = new THREE.DirectionalLight(0xffffff, 1);
        moonLight.position.set(-100, 100, 50);
        moonLight.castShadow = true;
        scene.add(moonLight);

        // Point light to simulate glimmer on waves
        const pointLight = new THREE.PointLight(0x00d2ff, 0.5, 1000);
        pointLight.position.set(50, 50, 50);
        scene.add(pointLight);

        // --- 3. Ocean Mesh (Custom Shader for Waves) ---
        // We use a high segment plane geometry to allow for smooth vertex displacement
        const geometry = new THREE.PlaneGeometry(300, 300, 100, 100);

        // Custom Shader Material
        const vertexShader = `
            uniform float uTime;
            uniform float uSpeed;
            uniform float uHeight;
            
            varying vec2 vUv;
            varying float vElevation;

            // Simple pseudo-random function
            float random(vec2 st) {
                return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
            }

            // Perlin-like noise function
            float noise(vec2 st) {
                vec2 i = floor(st);
                vec2 f = fract(st);
                float a = random(i);
                float b = random(i + vec2(1.0, 0.0));
                float c = random(i + vec2(0.0, 1.0));
                float d = random(i + vec2(1.0, 1.0));
                vec2 u = f * f * (3.0 - 2.0 * f);
                return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
            }

            void main() {
                vUv = uv;
                
                vec3 pos = position;
                
                // Create multiple layers of sine waves for complexity
                float wave1 = sin(pos.x * 0.05 + uTime * uSpeed) * uHeight * 2.0;
                float wave2 = sin(pos.y * 0.03 + uTime * uSpeed * 0.8) * uHeight * 2.0;
                
                // Add some noise for texture
                float n = noise(pos.xy * 0.05 + uTime * 0.1) * uHeight;

                pos.z += wave1 + wave2 + n;
                
                vElevation = pos.z;

                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `;

        const fragmentShader = `
            uniform vec3 uColorDeep;
            uniform vec3 uColorSurface;
            
            varying float vElevation;

            void main() {
                // Mix colors based on wave height (elevation)
                float mixStrength = (vElevation + 5.0) * 0.08;
                vec3 color = mix(uColorDeep, uColorSurface, mixStrength);
                
                gl_FragColor = vec4(color, 0.9);
            }
        `;

        const material = new THREE.ShaderMaterial({
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            uniforms: {
                uTime: { value: 0 },
                uSpeed: { value: 1.0 },
                uHeight: { value: 1.0 },
                uColorDeep: { value: new THREE.Color('#001e0f') },
                uColorSurface: { value: new THREE.Color('#006994') }
            },
            transparent: true,
            side: THREE.DoubleSide,
            wireframe: false
        });

        const water = new THREE.Mesh(geometry, material);
        water.rotation.x = -Math.PI / 2; // Lie flat
        scene.add(water);

        // --- 4. Controls Logic ---
        const speedInput = document.getElementById('speed');
        const heightInput = document.getElementById('height');
        const lightInput = document.getElementById('light');

        const valSpeed = document.getElementById('val-speed');
        const valHeight = document.getElementById('val-height');
        const valLight = document.getElementById('val-light');

        speedInput.addEventListener('input', (e) => {
            material.uniforms.uSpeed.value = parseFloat(e.target.value);
            valSpeed.textContent = e.target.value;
        });

        heightInput.addEventListener('input', (e) => {
            material.uniforms.uHeight.value = parseFloat(e.target.value);
            valHeight.textContent = e.target.value;
        });

        lightInput.addEventListener('input', (e) => {
            const intensity = parseFloat(e.target.value);
            moonLight.intensity = intensity;
            valLight.textContent = intensity;
        });

        // --- 5. Animation Loop ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            
            const elapsedTime = clock.getElapsedTime();
            material.uniforms.uTime.value = elapsedTime;

            // Gentle camera float
            camera.position.y = 30 + Math.sin(elapsedTime * 0.5) * 2;

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>

